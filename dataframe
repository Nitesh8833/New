import pandas as pd

def add_conformance_tat(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()

    start_candidates = [
        "prms_posted_timestamp", "prms_posted_time", "posted timestamp",
        "file_dropped_time", "file_dropped_timestamp", "prms_posted_ts",
    ]
    end_candidates = [
        "file_returned_timestamp", "processed_timestamp", "update_timestamp",
        "file_returned_time", "file_ingested_timestamp", "ingestion_timestamp",
        "file_ingestion_timestamp", "file_ingestion_time",
    ]

    # case-insensitive column map
    lower_map = {c.lower(): c for c in out.columns}

    # keep only candidates that actually exist in df
    start_cols = [lower_map[n.lower()] for n in start_candidates if n.lower() in lower_map]
    end_cols   = [lower_map[n.lower()] for n in end_candidates   if n.lower() in lower_map]

    if not start_cols or not end_cols:
        out["Conformance TAT"] = None
        return out

    # parse all candidate columns to UTC datetimes
    for c in start_cols + end_cols:
        out[c] = pd.to_datetime(out[c], errors="coerce", utc=True)

    # row-wise first non-null among candidates
    start_ts = out[start_cols].bfill(axis=1).iloc[:, 0]
    end_ts   = out[end_cols].bfill(axis=1).iloc[:, 0]

    # valid rows (both present)
    valid = start_ts.notna() & end_ts.notna()

    # compute end - start; clamp negatives to 0
    tat = pd.Series(pd.NaT, index=out.index, dtype="timedelta64[ns]")
    tat.loc[valid] = (end_ts[valid] - start_ts[valid]).dt.round("S")
    tat = tat.mask(tat < pd.Timedelta(0), pd.Timedelta(0))

    # format DD/HH/MM/SS
    comps = tat.dt.components
    tat_str = (
        comps["days"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["hours"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["minutes"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["seconds"].astype("Int64").astype(str).str.zfill(2)
    ).where(tat.notna(), None)

    out["Conformance TAT"] = tat_str
    return out
