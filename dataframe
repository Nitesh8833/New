import pandas as pd

def add_conformance_tat(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()

    # candidates (add/rename as needed)
    start_candidates = [
        "prms_posted_timestamp", "prms_posted_time", "posted timestamp",
        "file_dropped_time", "file_dropped_timestamp", "prms_posted_ts",
    ]
    end_candidates = [
        "file_returned_timestamp", "processed_timestamp", "update_timestamp",
        "file_returned_time", "file_ingested_timestamp", "ingestion_timestamp",
        "file_ingestion_timestamp", "file_ingestion_time",
    ]

    # helper to pick first existing col (case-insensitive)
    def find_col(d: pd.DataFrame, names):
        lower = {c.lower(): c for c in d.columns}
        for n in names:
            if n.lower() in lower:
                return lower[n.lower()]
        return None

    start_col = find_col(out, start_candidates)
    end_col   = find_col(out, end_candidates)

    if not start_col or not end_col:
        out["Conformance TAT"] = None
        return out

    # normalize datetimes (assume UTC if tz missing)
    out[start_col] = pd.to_datetime(out[start_col], errors="coerce", utc=True)
    out[end_col]   = pd.to_datetime(out[end_col],   errors="coerce", utc=True)

    # compute only where both present and end >= start
    valid = out[start_col].notna() & out[end_col].notna() & (out[end_col] >= out[start_col])

    tat = pd.Series(pd.NaT, index=out.index, dtype="timedelta64[ns]")
    tat.loc[valid] = (out.loc[valid, end_col] - out.loc[valid, start_col]).dt.round("S")

    # format DD/HH/MM/SS
    comps = tat.dt.components
    tat_str = (
        comps["days"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["hours"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["minutes"].astype("Int64").astype(str).str.zfill(2) + "/" +
        comps["seconds"].astype("Int64").astype(str).str.zfill(2)
    ).where(tat.notna(), None)

    out["Conformance TAT"] = tat_str
    return out
